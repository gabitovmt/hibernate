# Hibernate

## Терминология

* _ORM_, _Object-Relational Mapping_ - объектно-реляционное отображение.
* _JPA_, _Java Persistence API_ - спецификация ORM в Java.
* _JTA_, _Java Transaction API_ — API, для поддержки транзакций.
* _JPQL_, _Java Persistence Query Language_ - платформенно-независимый объектно-ориентированный язык запросов.
* _persistent data_ - данные, хранящиеся долговременно.
* _object persistence_ - долговременное хранение объектов.
* _data indepence_ - независимость данных.
* _DDL_, _Data Definition Language_ - язык описания данных.
* _DML_, _Data Manipulation Language_ - язык управления данными.
* _JDBC_, _Java Database Connectivity_ - API, соединение с базами данных на Java.
* _ACID_, _Atomicity_, _Consistency_, _Isolation_, _Durability_ -
Атомарность, Согласованность, Изолированность, Стойкость.
* _domain model_ - модель предметной области.
* _UDT, _User-defined Data Types_ - типы, определяемые пользователем.
* _problem of granularity_ - проблема детализации.
* _persistence unit_ - единица хранения.
* _JNDI_, _Java Naming and Directory Interface_ - это набор Java API, организованный в виде службы каталогов, который
позволяет Java-клиентам открывать и просматривать данные и объекты по их именам.

Объектно-реляционное отображение - это автоматическое (и прозрачное) сохранение объекта из Java-приложения
в таблицах базы данных SQL с использованием метаданных, описывающих отображение между классами приложения
и схемой базы данных SQL. ORM работает за счёт преобразования (двустороннего) данных из одного представления в другое.

## Основы объектно-реляционного отображения

### Долговременное хранение

#### Причины использования Hibernate:

* Продуктивность. Берёт большую часть рутиной работы.
* Простота сопровождения. Меньше строк кода: более понятная и удобная для рефакторинга.
* Производительность. Позволяет использовать множество оптимизаций.
* Независимость от поставщика. Разные СУБД.

#### Реляционные базы данных

Свойства:

* Независимость данных (СУБД может работать с несколькими приложениями).
* Данные существуют дольше, чем любое приложение.
* Целостность хранимых данных.

#### Действительно ли реляционная модель данных и (особенно) SQL являются правильным решением для долговременного хранения данных в объектно-ориентированных приложениях?

Да.

#### Теорема CAP.

Система не может быть согласованной, доступной и устойчивой к отказам разделов одновременно.

#### За модель предметной области.

* Получаем механизм ООП: наследование, полиморфизм и т.д.
* Применение шаблонов проектирования: Стратегия, Посредник, Компоновщик.
* Нетривиальная бизнес-логика.

#### Когда модель предметной области неоправдана.

* `ResultSet` - это всё, что нам нужно.
* Процедуры, выполняющие модификацию больших объёмов данных.
* Отчёты. Данные в табличном представлении.

### Несоответствие парадигм ООП и SQL.

#### Проблема детализации.

Например, у пользователя есть адрес. Адрес требуется детализированный. Пути решения:
* Сохранить поля в таблице пользователя.
* Сделать новый тип данных в БД.
* Сделать новую таблицу.

#### Проблема подтипов.

Есть суперкласс `BillingDetails`. Есть подклассы `CreditCard` и `BankAccount`. Как это реализовать в БД?

#### Проблема идентичности.

* Java. Идентичность экземпляров (`a == b`).
* Java. Равенство экземпляров (`equals()`).
* SQL. Primary key.

Если нет хорошего естественного ключа, то нужно создать суррогатный ключ.

А нужно ли Java знать о суррогатном ключе?

#### Проблемы, связанные с ассоциациями

На Java реализуется с помощью указателей.

В БД с помощью внешнего ключа. Когда связь многие-ко-многим, то используется _таблица ссылок_ (_link table_).

#### Проблемы с навигацией.

На Java используется `iterator()`. Для БД это плохая идея, из-за большого количества запросов к БД.
Проблемы _n + 1 запроса_ и _декартова произведения_.

## С чего начать

### JPA

1. Необходимо создать _persistence unit_. Её конфигурационный файл располагается в `classpath:META-INF/persistene.xml`.
2. Должен быть настроен _JNDI_ и _JTA_. Примеры библиотек: _bitronix_, _atomikos_.
3. Источник данных `java.sql.DataSource`. Должен находиться в _JNDI_.
4. Создать `javax.persistence.EntityManagerFactory`. Обычно он один на всё приложение.

Пример работы см. код `com.example.helloworld.HelloWorldJPA`.

#### Журналирование SQL

Нужно включить (`true`) свойства `hibernate.format_sql` и `hibernate.user_sql_comments`.
В настройках журналирования для категорий `org.hibernate.SQL` и `org.hibernate.type.descriptor.sql.BasicBinder`
установить `TRACE`.

#### Настройка JTA

См. код `com.example.env.TransactionManagerSetup` и файл `classpath:jndi.properties`.

### Hibernate

0. _JDK 6_, _7_, _8_, если _Hibernate 5.0.1.Final_.
На более старших версиях _JDK_ встречались проблемы при xml-конфигурировании.
1. Должен быть _JNDI_ и _JTA_.
2. Конфигурационный файл `classpath:hibernate.cfg.xml`. Название можно устанавливать своё.
Файл можно заменить на программную конфигурацию.
3. Создать `org.hibernate.service.ServiceRegistry`.
4. С помощью `org.hibernate.boot.MetadataSource` указать какие классы участвуют в отображении.
5. Создать `org.hibernate.boot.Metadata`.
6. Итог должен быть `org.hibernate.SessionFactory`. Обычно он один на всё приложение.

Пример работы см. код `com.example.heeloworld.HelloWorldHibernate`.