# Hibernate

## Терминология

* _ORM_, _Object-Relational Mapping_ - объектно-реляционное отображение.
* _JPA_, _Java Persistence API_ - спецификация ORM в Java.
* _JTA_, _Java Transaction API_ — API, для поддержки транзакций.
* _JPQL_, _Java Persistence Query Language_ - платформенно-независимый объектно-ориентированный язык запросов.
* _persistent data_ - данные, хранящиеся долговременно.
* _object persistence_ - долговременное хранение объектов.
* _data indepence_ - независимость данных.
* _DDL_, _Data Definition Language_ - язык описания данных.
* _DML_, _Data Manipulation Language_ - язык управления данными.
* _JDBC_, _Java Database Connectivity_ - API, соединение с базами данных на Java.
* _ACID_, _Atomicity_, _Consistency_, _Isolation_, _Durability_ -
   Атомарность, Согласованность, Изолированность, Стойкость.
* _domain model_ - модель предметной области.
* _UDT, _User-defined Data Types_ - типы, определяемые пользователем.
* _problem of granularity_ - проблема детализации.
* _persistence unit_ - единица хранения.
* _JNDI_, _Java Naming and Directory Interface_ - это набор Java API, организованный в виде службы каталогов, который
   позволяет Java-клиентам открывать и просматривать данные и объекты по их именам.
* _модель предметной области_ - концептуальная модель сущностей и их атрибутов.
* _POJO_, _Plain Old Java Objects_ - старые добрые объекты Java.
* _RMI_, _Remote Method Invocation_ - механизм удалённого вызова методов.

Объектно-реляционное отображение - это автоматическое (и прозрачное) сохранение объекта из Java-приложения
в таблицах базы данных SQL с использованием метаданных, описывающих отображение между классами приложения
и схемой базы данных SQL. ORM работает за счёт преобразования (двустороннего) данных из одного представления в другое.

## Основы объектно-реляционного отображения

### Долговременное хранение

#### Причины использования Hibernate:

* Продуктивность. Берёт большую часть рутиной работы.
* Простота сопровождения. Меньше строк кода: более понятная и удобная для рефакторинга.
* Производительность. Позволяет использовать множество оптимизаций.
* Независимость от поставщика. Разные СУБД.

#### Реляционные базы данных

Свойства:

* Независимость данных (СУБД может работать с несколькими приложениями).
* Данные существуют дольше, чем любое приложение.
* Целостность хранимых данных.

#### Действительно ли реляционная модель данных и (особенно) SQL являются правильным решением для долговременного хранения данных в объектно-ориентированных приложениях?

Да.

#### Теорема CAP.

Система не может быть согласованной, доступной и устойчивой к отказам разделов одновременно.

#### За модель предметной области.

* Получаем механизм ООП: наследование, полиморфизм и т.д.
* Применение шаблонов проектирования: Стратегия, Посредник, Компоновщик.
* Нетривиальная бизнес-логика.

#### Когда модель предметной области неоправдана.

* `ResultSet` - это всё, что нам нужно.
* Мало сущностей.
* Несложная бизнес-логика.
* Несложные взаимодействия между сущностями.
* Процедуры, выполняющие модификацию больших объёмов данных.
* Отчёты. Данные в табличном представлении.

### Несоответствие парадигм ООП и SQL.

#### Проблема детализации.

Например, у пользователя есть адрес. Адрес требуется детализированный. Пути решения:
* Сохранить поля в таблице пользователя.
* Сделать новый тип данных в БД.
* Сделать новую таблицу.

#### Проблема подтипов.

Есть суперкласс `BillingDetails`. Есть подклассы `CreditCard` и `BankAccount`. Как это реализовать в БД?

#### Проблема идентичности.

* Java. Идентичность экземпляров (`a == b`).
* Java. Равенство экземпляров (`equals()`).
* SQL. Primary key.

Если нет хорошего естественного ключа, то нужно создать суррогатный ключ.

А нужно ли Java знать о суррогатном ключе?

#### Проблемы, связанные с ассоциациями

На Java реализуется с помощью указателей.

В БД с помощью внешнего ключа. Когда связь многие-ко-многим, то используется _таблица ссылок_ (_link table_).

#### Проблемы с навигацией.

На Java используется `iterator()`. Для БД это плохая идея, из-за большого количества запросов к БД.
Проблемы _n + 1 запроса_ и _декартова произведения_.

## С чего начать

### JPA

1. Необходимо создать _persistence unit_. Её конфигурационный файл располагается в `classpath:META-INF/persistene.xml`.
2. Должен быть настроен _JNDI_ и _JTA_. Примеры библиотек: _bitronix_, _atomikos_.
3. Источник данных `java.sql.DataSource`. Должен находиться в _JNDI_.
4. Создать `javax.persistence.EntityManagerFactory`. Обычно он один на всё приложение.

Пример работы см. код `com.example.helloworld.HelloWorldJPA` (модуль `hello-world`).

#### Журналирование SQL

Нужно включить (`true`) свойства `hibernate.format_sql` и `hibernate.user_sql_comments`.
В настройках журналирования для категорий `org.hibernate.SQL` и `org.hibernate.type.descriptor.sql.BasicBinder`
установить `TRACE`.

#### Настройка JTA

См. код `com.example.env.TransactionManagerSetup` и файл `classpath:jndi.properties` (модуль `base`).

### Hibernate

0. _JDK 6_, _7_, _8_, если _Hibernate 5.0.1.Final_.
На более старших версиях _JDK_ встречались проблемы при xml-конфигурировании.
1. Должен быть _JNDI_ и _JTA_.
2. Конфигурационный файл `classpath:hibernate.cfg.xml`. Название можно устанавливать своё.
   Файл можно заменить на программную конфигурацию.
3. Создать `org.hibernate.service.ServiceRegistry`.
4. С помощью `org.hibernate.boot.MetadataSource` указать какие классы участвуют в отображении.
5. Создать `org.hibernate.boot.Metadata`.
6. Итог должен быть `org.hibernate.SessionFactory`. Обычно он один на всё приложение.

Пример работы см. код `com.example.helloworld.HelloWorldHibernate` (модуль `hello-world`).

## Модели предметной области и метаданные

### Предметная модель

#### Многоуровневая архитектура

~~~
     V--------- Уровень представления --------------V
  Модель                  V                Обработчики, утилиты
предметной <--- Уровень бизнес логики ----> и вспомогательные
  области                 V                      классы
     ^----------- Уровень хранения -----------------^
                          V
                     Базы данных
~~~

Примечания.
* Реализация уровня зависит от интерфейса уровня, который находится под ним.
* _Сквозные задачи_ не входят в уровни.
* Модель предметной области может быть общей или у каждой своя.
* Если уровень представления находится на другом компьютере, то лучше для неё использовать отдельную модель
  предметной области.

### Реализация предметной области

#### Предотвращение утечек функциональности

(_leakage of concerns_)

В предметную модель не должны просачиваться функциональность, как хранение данных, управление транзакциями,
авторизация, использование _JNDI_ и _JDBC_ и т.д.

Плюсы такого подхода:
* Повторное использование классов в разных уровнях.
* Легкость проведения модульного тестирования.

#### Создание классов с возможностью сохранения

* _POJO_.
* Не обязательность реализовывать `java.io.Serializable`.
* Класс может быть абстрактным.
* Не может быть финальным как он, так и его методы.
* Должен быть верхнего уровня.
* Иметь конструктор без аргументов с областью видимости не ниже пакета.
* _Getter-_ и _setter-_ методы не обязательны (зависит от настроек _Hibernate_).
* В качестве коллекций использовать только интерфейсы.

**_Hibernate_ автоматически определяет изменение состояния. Обычные поля по значению, коллекции - по идентичности!**

Рекомендации:
* Желательно инициализировать поля коллекций, а не оставлять `null`.
* Рекомендуют использовать `java.util.Set`. Если нужен порядок элементов, сортируйте при извлечении из БД (в запросе)
  или/и при показе пользователю (в Java-коде).
* Для аннотаций из `org.hibernate` использовать полное имя (т.е. вместе с именем пакета).
  Так будет понятно, что используется из не _JPA_.

Пример реализации см. код `com.example.model.simple.SimpleModel` (модуль `hello-world`).

При двунаправленной связи необходимо выполнять два действия:
~~~
parent.getChildren.add(child);
child.setParent(parent);
~~~

#### Применение валидации

* Механизм валидации будет обращаться напрямую к полям класса, если их пометить аннотациями.
* Если предпочитаете методы доступа, помечать нужно _getter-методы_.

Пример использования см. код `com.example.model.simple.ModelOperations` и
`com.example.model.simple.ModelOperationsSave` (модуль `hello-world`).

#### Метаданные во внешних XML-файлах

##### JPA

_JPA_ автоматически ищет файл `classpath:META-INF/orm.xml`. Если директория и имя файла другое, необходимо указать его
в `<persistence-unit>` с помощью элемента `<mapping-file>`.

Примеры см. код `com.example.model.simple.SimpleXml` и файлы `classpath:META-INF\persistence.xml`,
`classpath:META-INF\simple_xml_complete_pu_orm.xml` и `classpath:META-INF\simple_xml_pu_orm.xml` (модуль `hello-world`).

**Все** свойства класса являются хранимыми.

##### Hibernate

По соглашению файл должен иметь то же имя и пакет, что и класс:
`my/model/Item.hbm.xml` для `my.model.Item`.

Отображение класса в XML-документе считается завершённым. Нельзя переопределять аннотации в классе, как в JPA.

Если свойство не имеет отображения, оно считается **временным**.

Примеры см. код `com.example.model.simple.SimpleXml` и файлы `classpath:simple_xml.cfg.xml` и
`classpath:com/example/model/simple/Item.hbm.xml` (модуль `hello-world`).